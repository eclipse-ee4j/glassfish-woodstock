/*
 * Copyright (c) 2007, 2018 Oracle and/or its affiliates. All rights reserved.
 *
 * This program and the accompanying materials are made available under the
 * terms of the Eclipse Public License v. 2.0, which is available at
 * http://www.eclipse.org/legal/epl-2.0.
 *
 * This Source Code may also be made available under the following Secondary
 * Licenses when the conditions for such availability set forth in the
 * Eclipse Public License v. 2.0 are satisfied: GNU General Public License,
 * version 2 with the GNU Classpath Exception, which is available at
 * https://www.gnu.org/software/classpath/license.html.
 *
 * SPDX-License-Identifier: EPL-2.0 OR GPL-2.0 WITH Classpath-exception-2.0
 */
package com.sun.faces.mirror;

import java.util.regex.Pattern;

/**
 * A base class that defines the basic metadata available for any component
 * feature, whether a property or event.
 *
 * @author gjmurphy
 */
public abstract class FeatureInfo {

    /**
     * Pattern used in property info analysis to determine if a name is a Java
     * keyword or reserved word.
     */
    static Pattern JAVA_KEYWORD_PATTERN = Pattern.compile(
            "("
            + "assert|boolean|break|byte|case|catch|char|class|const|continue|default|do|double|else|"
            + "enum|extends|false|final|finally|float|for|goto|if|implements|import|instanceof|int|"
            + "interface|long|native|new|null|package|private|protected|public|return|short|static|"
            + "super|switch|synchronized|this|throw|throws|transient|true|try|void|volatile|while"
            + ")"
    );

    private ClassInfo declaringClassInfo;

    /**
     * Returns the name of this feature, which is guaranteed to be unique within
     * the scope of the containing component.
     *
     * @return String
     */
    public abstract String getName();

    /**
     * Returns the display name of this property.If no display name was assigned
     * to this feature, should return the feature name.
     *
     * @return String
     */
    public abstract String getDisplayName();

    /**
     * Returns a short description of this property.If no short description was
     * assigned to this feature, should return the feature's display name.
     *
     * @return String
     */
    public abstract String getShortDescription();

    /**
     * Test if this feature is hidden.
     *
     * @return {@code true} if this feature should be hidden at design-time
     */
    public abstract boolean isHidden();

    /**
     * Returns the class info of the class that declared this feature.This is
     * useful when a property or event is retrieved from a class that reports
     * its inherited properties and events. Returns null if the super class is
     * {@code java.lang.Object}.
     *
     * @return ClassInfo
     */
    public ClassInfo getDeclaringClassInfo() {
        return this.declaringClassInfo;
    }

    void setDeclaringClassInfo(ClassInfo declaringClassInfo) {
        this.declaringClassInfo = declaringClassInfo;
    }

    /**
     * Returns a unique, generated key for the property specified, suitable for
     * use as a key in a properties resource bundle file, if the property
     * corresponds to a localizable annotation element.For example, the property
     * {@link PropertyInfo#getDisplayName}) corresponds to the localizable
     * annotation element {@link com.sun.faces.Property#displayName} so a unique
     * key for it may be generated by calling<pre>
     *    String key = propertyInfo.getKey("displayName");
     * </pre> If the specified property does not correspond to a localizable
     * annotation, returns null. If the specified property does not exist,
     * throws {@link
     * java.lang.NoSuchMethodException}. Only properties of type
     * {@link java.lang.String} are supported.
     *
     * @param propertyName
     * @return String
     * @throws java.lang.NoSuchMethodException if the method is not found
     */
    public final String getKey(String propertyName) throws NoSuchMethodException {
        String methodName = "get" + propertyName.substring(0, 1).toUpperCase()
                + propertyName.substring(1);
        this.getClass().getMethod(methodName);
        String baseName = this.getDeclaringClassInfo().getClassName();
        return baseName + "_" + this.getName() + "_" + propertyName;
    }

    @Override
    public int hashCode() {
        int hash = 5;
        hash = 67 * hash + (this.declaringClassInfo != null ? this.declaringClassInfo.hashCode() : 0);
        String name = this.getName();
        hash = 67 * hash + (name != null ? name.hashCode() : 0);
        return hash;
    }

    @Override
    public boolean equals(Object obj) {
        if (this == obj) {
            return true;
        }
        if (obj == null) {
            return false;
        }
        if (getClass() != obj.getClass()) {
            return false;
        }
        final FeatureInfo other = (FeatureInfo) obj;
        if (this.declaringClassInfo != other.declaringClassInfo
                && (this.declaringClassInfo == null
                || !this.declaringClassInfo.equals(other.declaringClassInfo))) {
            return false;
        }
        String thisName = this.getName();
        String otherName = other.getName();
        return !(thisName != otherName
                && (thisName == null || !thisName.equals(otherName)));
    }
}
