/*
 * Copyright (c) 2007, 2020 Oracle and/or its affiliates. All rights reserved.
 *
 * This program and the accompanying materials are made available under the
 * terms of the Eclipse Public License v. 2.0, which is available at
 * http://www.eclipse.org/legal/epl-2.0.
 *
 * This Source Code may also be made available under the following Secondary
 * Licenses when the conditions for such availability set forth in the
 * Eclipse Public License v. 2.0 are satisfied: GNU General Public License,
 * version 2 with the GNU Classpath Exception, which is available at
 * https://www.gnu.org/software/classpath/license.html.
 *
 * SPDX-License-Identifier: EPL-2.0 OR GPL-2.0 WITH Classpath-exception-2.0
 */

package com.sun.webui.jsf.model;

import java.io.UnsupportedEncodingException;
import java.net.URLEncoder;
import javax.faces.FacesException;
import javax.faces.component.UIComponent;

/**
 * Utility bean that serves as an accumulating buffer for
 * well formed markup fragments typically generated by renderers.
 * The fundamental API is modeled after {@code ResponseWriter}
 * in JavaServer Faces.
 */
public class Markup {

    /**
     * Entities from HTML 4.0, section {@code 24.2.1}
     * character codes {@code 0xA0} to {@code0xFF}.
     */
    private static final String[] ISO8859_1_ENTITIES = new String[]{
        "nbsp",
        "iexcl",
        "cent",
        "pound",
        "curren",
        "yen",
        "brvbar",
        "sect",
        "uml",
        "copy",
        "ordf",
        "laquo",
        "not",
        "shy",
        "reg",
        "macr",
        "deg",
        "plusmn",
        "sup2",
        "sup3",
        "acute",
        "micro",
        "para",
        "middot",
        "cedil",
        "sup1",
        "ordm",
        "raquo",
        "frac14",
        "frac12",
        "frac34",
        "iquest",
        "Agrave",
        "Aacute",
        "Acirc",
        "Atilde",
        "Auml",
        "Aring",
        "AElig",
        "Ccedil",
        "Egrave",
        "Eacute",
        "Ecirc",
        "Euml",
        "Igrave",
        "Iacute",
        "Icirc",
        "Iuml",
        "ETH",
        "Ntilde",
        "Ograve",
        "Oacute",
        "Ocirc",
        "Otilde",
        "Ouml",
        "times",
        "Oslash",
        "Ugrave",
        "Uacute",
        "Ucirc",
        "Uuml",
        "Yacute",
        "THORN",
        "szlig",
        "agrave",
        "aacute",
        "acirc",
        "atilde",
        "auml",
        "aring",
        "aelig",
        "ccedil",
        "egrave",
        "eacute",
        "ecirc",
        "euml",
        "igrave",
        "iacute",
        "icirc",
        "iuml",
        "eth",
        "ntilde",
        "ograve",
        "oacute",
        "ocirc",
        "otilde",
        "ouml",
        "divide",
        "oslash",
        "ugrave",
        "uacute",
        "ucirc",
        "uuml",
        "yacute",
        "thorn",
        "yuml"
    };

    /**
     * Buffer into which we accumulate the created markup.
     */
    private final StringBuilder buffer = new StringBuilder();

    /**
     * The character encoding that we assume will be used when
     * the markup contained in this instance is rendered.  The
     * default value ("ISO-8859-1") is an attempt to be conservative.
     */
    private String encoding = "ISO-8859-1";

    /**
     * Flag indicating that an element is currently open.
     */
    private boolean open = false;

    /**
     * Return the character encoding assumed to be used when the
     * markup contained in this instance is ultimately rendered.
     * @return String
     */
    public String getEncoding() {
        return this.encoding;
    }

    /**
     * Set the character encoding assumed to be used when the
     * markup contained in this instance is ultimately rendered.
     *
     * @param newEncoding The new character encoding
     */
    public void setEncoding(final String newEncoding) {
        this.encoding = newEncoding;
    }

    /**
     * Return the markup that has been accumulated in this element,
     * as a String suitable for direct transcription to the response
     * buffer.
     * @return String
     */
    public String getMarkup() {
        close();
        return buffer.toString();
    }

    /**
     * Clear any accumulated markup stored in this object,
     * making it suitable for reuse.
     */
    public void clear() {
        buffer.setLength(0);
        open = false;
    }

    /**
     * Return the markup that has been accumulated in this element.This is an
     * alias for the {@code getMarkup()} method.
     *
     * @return String
     */
    @Override
    public String toString() {
        return getMarkup();
    }

    /**
     * Accumulate the start of a new element, up to and including
     * the element name.  Once this method has been called, clients
     * can call {@code writeAttribute()} or
     * {@code writeURIAttriute()} to add attributes and their
     * corresponding values.  The starting element will be closed
     * on any subsequent call to {@code startElement()},
     * {@code writeComment()}, {@code writeText()},
     * {@code writeRaw()}, {@code endElement()}, or
     * {@code getMarkup()}.
     *
     * @param name Name of the element to be started
     * @param component The {@code UIComponent} (if any)
     *  to which this element corresponds
     *
     * @exception NullPointerException if {@code name}
     *  is {@code null}
     */
    public void startElement(final String name, final UIComponent component) {

        if (name == null) {
            throw new NullPointerException();
        }
        close();
        buffer.append('<');
        buffer.append(name);
        open = true;
    }

    /**
     * Accumulate the end of an element, after closing any open element
     * created by a call to {@code startElement()}.  Elements must be
     * closed in the inverse order from which they were opened; it is an
     * error to do otherwise.
     *
     * @param name Name of the element to be ended
     *
     * @exception NullPointerException if {@code name}
     *  is {@code null}
     */
    public void endElement(final String name) {
        if (name == null) {
            throw new NullPointerException();
        }
        if (open) {
            buffer.append('/');
            close();
        } else {
            buffer.append("</");
            buffer.append(name);
            buffer.append('>');
        }
    }

    /**
     * Accumulate an attribute name and corresponding value.  This
     * method may only be called after a call to {@code startElement()}
     * and before the opened element has been closed.
     *
     * @param name Attribute name to be added
     * @param value Attribute value to be added
     * @param property Name of the component property or attribute (if any)
     *  of the {@code UIComponent} associated with the containing
     *  element, to which the generated attribute corresponds
     *
     * @exception IllegalStateException if this method is called
     *  when there is no currently open element
     * @exception NullPointerException if {@code name}
     *  or {@code value} is {@code null}
     */
    @SuppressWarnings("checkstyle:magicnumber")
    public void writeAttribute(final String name, final Object value,
            final String property) {

        if ((name == null) || (value == null)) {
            throw new NullPointerException();
        }
        if (!open) {
            throw new IllegalStateException("No element is currently open");
        }

        // Handle boolean values specially
        Class clazz = value.getClass();
        if (clazz == Boolean.class) {
            if (Boolean.TRUE.equals(value)) {
                // No attribute minimization for XHTML like markup
                buffer.append(' ');
                buffer.append(name);
                buffer.append("=\"");
                buffer.append(name);
                buffer.append('"');
            // } else {
            // Write nothing for false boolean attributes
            }
            return;
        }

        // Render the attribute name and beginning of the value
        buffer.append(' ');
        buffer.append(name);
        buffer.append("=\"");

        // Render the value itself
        String text = value.toString();
        int length = text.length();
        for (int i = 0; i < length; i++) {
            char ch = text.charAt(i);

            // Tilde or less...
            if (ch < 0xA0) {
                // If "?" or over, no escaping is needed (this covers
                // most of the Latin alphabet)
                if (ch >= 0x3f) {
                    buffer.append(ch);
                } else if (ch >= 0x27) { // If above "'"...
                    // If between "'" and ";", no escaping is needed
                    if (ch < 0x3c) {
                        buffer.append(ch);
                        // Note - "<" isn't escaped in attributes, as per
                        // HTML spec
                    } else if (ch == '>') {
                        buffer.append("&gt;");
                    } else {
                        buffer.append(ch);
                    }
                } else {
                    switch (ch) {
                        case '&':
                            // HTML 4.0, section B.7.1: ampersands followed by
                            // an open brace don't get escaped
                            if ((i + 1 < length)
                                    && (text.charAt(i + 1) == '{')) {
                                buffer.append(ch);
                            } else {
                                buffer.append("&amp;");
                            }
                            break;
                        case '"':
                            buffer.append("&quot;");
                            break;
                        default:
                            buffer.append(ch);
                            break;
                    }
                }
            } else if (ch <= 0xff) {
                // ISO-8859-1 entities: encode as needed
                buffer.append('&');
                buffer.append(ISO8859_1_ENTITIES[ch - 0xA0]);
                buffer.append(';');
            } else {
                // Double-byte characters to encode.
                // PENDING: when outputting to an encoding that
                // supports double-byte characters (UTF-8, for example),
                // we should not be encoding
                numeric(ch);
            }
        }

        // Render the end of the value
        buffer.append('"');
    }

    /**
     * Accumulate an attribute name and corresponding URI value.  This
     * method may only be called after a call to {@code startElement()}
     * and before the opened element has been closed.
     *
     * @param name Attribute name to be added
     * @param value Attribute value to be added
     * @param property Name of the component property or attribute (if any)
     *  of the {@code UIComponent} associated with the containing
     *  element, to which the generated attribute corresponds
     *
     * @exception IllegalStateException if this method is called
     *  when there is no currently open element
     * @exception NullPointerException if {@code name}
     *  or {@code value} is {@code null}
     */
    @SuppressWarnings("checkstyle:magicnumber")
    public void writeURIAttribute(final String name, final Object value,
            final String property) {

        if ((name == null) || (value == null)) {
            throw new NullPointerException();
        }
        if (!open) {
            throw new IllegalStateException("No element is currently open");
        }

        String text = value.toString();
        if (text.startsWith("javascript:")) {
            writeAttribute(name, value, property);
            return;
        }

        // Render the attribute name and beginning of the value
        buffer.append(' ');
        buffer.append(name);
        buffer.append("=\"");

        // Render the value itself
        int length = text.length();

        for (int i = 0; i < length; i++) {
            char ch = text.charAt(i);

            if ((ch < 33) || (ch > 126)) {
                if (ch == ' ') {
                    buffer.append('+');
                } else {
                    // ISO-8859-1.  Blindly assume the character will be < 255.
                    // Not much we can do if it isn't.
                    hexadecimals(ch);
                }
            } else if (ch == '"') {
                // DO NOT encode '%'.  If you do, then for starters,
                // we'll double-encode anything that's pre-encoded.
                // And, what's worse, there becomes no way to use
                // characters that must be encoded if you
                // don't want them to be interpreted, like '?' or '&'.
                // else if('%' == ch)
                // {
                //   hexadecimals(ch);
                // }
                buffer.append("%22");
            } else if (ch == '?') {
                // Everything in the query parameters will be decoded
                // as if it were in the request's character set.  So use
                // the real encoding for those!
                buffer.append('?');
                try {
                    buffer.append(URLEncoder.encode(text.substring(i + 1),
                            encoding));
                } catch (UnsupportedEncodingException e) {
                    throw new FacesException(e);
                }
                break;
            } else {
                buffer.append(ch);
            }
        }

        // Render the end of the value
        buffer.append('"');

    }

    /**
     * Accumulate a comment containing the specified text, after
     * converting that text to a String (if necessary) and performing
     * any escaping appropriate for the markup language being rendered.
     *
     * <p>If there is an open element that has been created by a call to
     * {@code startElement()}, that element will be closed first.</p>
     *
     * @param comment Text content of the comment
     *
     * @exception NullPointerException if {@code comment}
     *  is {@code null}
     */
    public void writeComment(final Object comment) {
        if (comment == null) {
            throw new NullPointerException();
        }
        close();
        buffer.append("<!-- ");
        buffer.append(comment); // FIXME - filtering?
        buffer.append(" -->");
    }

    /**
     * <p>Accumulate an object, after converting it to a String (if necessary)
     * <strong>WITHOUT</strong> performing escaping appropriate for the
     * markup language being rendered.</p>
     * <p>If there is an open element that has been created by a call to
     * {@code startElement()}, that element will be closed first.</p>
     *
     * @param raw Raw content to be written
     * @param property Name of the component property or attribute (if any)
     *  of the {@code UIComponent} associated with the containing
     *  element, to which the generated content corresponds
     *
     * @exception NullPointerException if {@code text}
     *  is {@code null}
     */
    public void writeRaw(final Object raw, final String property) {

        if (raw == null) {
            throw new NullPointerException();
        }
        close();
        buffer.append(raw.toString());
    }

    /**
     * <p>Accumulate an object, after converting it to a String (if necessary)
     * and after performing any escaping appropriate for the markup
     * language being rendered.</p>
     *
     * <p>If there is an open element that has been created by a call to
     * {@code startElement()}, that element will be closed first.</p>
     *
     * @param text Text to be written
     * @param property Name of the component property or attribute (if any)
     *  of the {@code UIComponent} associated with the containing
     *  element, to which the generated attribute corresponds
     *
     * @exception NullPointerException if {@code text}
     *  is {@code null}
     */
    @SuppressWarnings("checkstyle:magicnumber")
    public void writeText(final Object text, final String property) {

        if (text == null) {
            throw new NullPointerException();
        }
        // Close any open element
        close();

        // Render the filtered version of the specified text
        String stext = text.toString();
        int length = stext.length();

        for (int i = 0; i < length; i++) {
            char ch = stext.charAt(i);

            // Tilde or less...
            if (ch < 0xA0) {
                // If "?" or over, no escaping is needed (this covers
                // most of the Latin alphabet)
                if (ch >= 0x3f) {
                    buffer.append(ch);
                } else if (ch >= 0x27) {  // If above "'"...
                    // If between "'" and ";", no escaping is needed
                    if (ch < 0x3c) {
                        buffer.append(ch);
                    } else if (ch == '<') {
                        buffer.append("&lt;");
                    } else if (ch == '>') {
                        buffer.append("&gt;");
                    } else {
                        buffer.append(ch);
                    }
                } else {
                    if (ch == '&') {
                        buffer.append("&amp;");
                    } else {
                        buffer.append(ch);
                    }
                }
            } else if (ch <= 0xff) {
                // ISO-8859-1 entities: encode as needed
                buffer.append('&');
                buffer.append(ISO8859_1_ENTITIES[ch - 0xA0]);
                buffer.append(';');
            } else {
                // Double-byte characters to encode.
                // PENDING: when outputting to an encoding that
                // supports double-byte characters (UTF-8, for example),
                // we should not be encoding
                numeric(ch);
            }
        }
    }

    /**
     * Close the currently open starting element, if any.
     */
    protected void close() {
        if (open) {
            buffer.append('>');
            open = false;
        }
    }

    /**
     * >Append the hexadecimal equivalent of the specified
     * numeric value.
     * @param i value
     */
    @SuppressWarnings("checkstyle:magicnumber")
    protected void hexadecimal(final int i) {
        if (i < 10) {
            buffer.append((char) ('0' + i));
        } else {
            buffer.append((char) ('A' + (i - 10)));
        }

    }

    /**
     * Append the specified character as an escaped two-hex-digit value.
     * @param ch Character to be escaped
     */
    @SuppressWarnings("checkstyle:magicnumber")
    protected void hexadecimals(final char ch) {
        buffer.append('%');
        hexadecimal((int) ((ch >> 4) % 0x10));
        hexadecimal((int) (ch % 0x10));
    }

    /**
     * Append a numeric escape for the specified character.
     * @param ch Character to be escaped
     */
    @SuppressWarnings("checkstyle:magicnumber")
    protected void numeric(final char ch) {

        if (ch == '\u20ac') {
            buffer.append("&euro;");
            return;
        }

        // Formerly used String.valueOf().  This version tests out
        // about 40% faster in a microbenchmark (and on systems where GC is
        // going gonzo, it should be even better)
        int i = (int) ch;
        if (i > 10000) {
            buffer.append('0' + (i / 10000));
            i = i % 10000;
            buffer.append('0' + (i / 1000));
            i = i % 1000;
            buffer.append('0' + (i / 100));
            i = i % 100;
            buffer.append('0' + (i / 10));
            i = i % 10;
            buffer.append('0' + i);
        } else if (i > 1000) {
            buffer.append('0' + (i / 1000));
            i = i % 1000;
            buffer.append('0' + (i / 100));
            i = i % 100;
            buffer.append('0' + (i / 10));
            i = i % 10;
            buffer.append('0' + i);
        } else {
            buffer.append('0' + (i / 100));
            i = i % 100;
            buffer.append('0' + (i / 10));
            i = i % 10;
            buffer.append('0' + i);
        }
        buffer.append(';');
    }
}
