/*
 * Copyright (c) 2007, 2020 Oracle and/or its affiliates. All rights reserved.
 * Copyright (c) 2020 Payara Services Ltd.
 *
 * This program and the accompanying materials are made available under the
 * terms of the Eclipse Public License v. 2.0, which is available at
 * http://www.eclipse.org/legal/epl-2.0.
 *
 * This Source Code may also be made available under the following Secondary
 * Licenses when the conditions for such availability set forth in the
 * Eclipse Public License v. 2.0 are satisfied: GNU General Public License,
 * version 2 with the GNU Classpath Exception, which is available at
 * https://www.gnu.org/software/classpath/license.html.
 *
 * SPDX-License-Identifier: EPL-2.0 OR GPL-2.0 WITH Classpath-exception-2.0
 */

package com.sun.webui.jsf.faces;

import com.sun.faces.annotation.Resolver;
import java.util.ArrayList;
import java.util.List;
import javax.el.ELResolver;
import javax.el.ELContext;
import javax.el.PropertyNotFoundException;
import javax.faces.model.SelectItem;
import com.sun.data.provider.DataProvider;
import com.sun.data.provider.DataProviderException;
import com.sun.data.provider.FieldKey;
import com.sun.data.provider.RowKey;
import com.sun.data.provider.TableCursorVetoException;
import com.sun.data.provider.TableDataProvider;
import com.sun.data.provider.impl.TableRowDataProvider;
import com.sun.webui.jsf.model.Option;
import com.sun.webui.jsf.util.LogUtil;
import java.util.Iterator;
import java.beans.FeatureDescriptor;
import java.util.Arrays;

/**
 * {@code DataProviderPropertyResolver} is a {@code PropertyResolver}
 * implementation that, if the {@code base} parameter is a {@link DataProvider},
 * passes calls to {@code getValue()},
 * {@code getType()}, {@code isReadOnly()}, and {@code setValue()} to the
 * corresponding {@link DataProvider} instance.
 *
 * These expressions are supported:
 *
 * <ul>
 * <li> {@code #{...myDataProvider.value.FIELD_ID}}<br>
 * {@code #{...myDataProvider.value['FIELD_ID']}}<br>
 * --> binds to the value of the {@link FieldKey} corresponding to 'FIELD_ID' in
 * a DataProvider *or* the cursor row of a TableDataProvider. If the specified
 * FIELD_ID does not correspond to a FieldKey in the DataProvider, this property
 * resolver will throw a PropertyNotFoundException, and include any nested
 * exceptions.</li>
 *
 * <li> {@code #{...myDataProvider.value[':ROWKEY:']}}<br>
 * --> binds to the 'cursorRow' {@link RowKey} of a TableDataProvider or the
 * 'tableRow' RowKey of a TableRowDataProvider. If the DataProvider is not one
 * of these, this binds to nothing. Note that cursor or tableRow can be *driven*
 * by this binding. It is not read-only.</li>
 *
 * <li> {@code #{...myDataProvider.value[':ROWID:']}}<br>
 * --> binds to the 'cursorRow' {@link RowKey}'s ID (String) of a
 * TableDataProvider or the 'tableRow' RowKey's ID of a TableRowDataProvider. If
 * the DataProvider is not one of these, this binds to nothing. Note that cursor
 * or tableRow can be *driven* by this binding. It is not read-only.
 * </li>
 *
 * <li> {@code #{...myDataProvider.selectItems.FIELD_ID}}<br>
 * {@code #{...myDataProvider.selectItems['FIELD_ID']}}<br>
 * {@code #{...myDataProvider.selectItems['VALUE_FIELD_ID,LABEL_FIELD_ID']}}<br>
 * {@code #{...myDataProvider.selectItems['VALUE_FIELD_ID,LABEL_FIELD_ID,
 * DESC_FIELD_ID']}}<br>
 * {@code #{...myDataProvider.selectItems[':ROWKEY:,:ROWKEY:,:ROWKEY:']}}<br>
 * {@code #{...myDataProvider.selectItems[':ROWID:,:ROWID:,:ROWID:']}}<br>
 * --> binds to an array of {@link SelectItem} generated by scanning the rows of
 * the TableDataProvider (without moving the cursor). If the base object is a
 * DataProvider, but not a TableDataProvider, the resulting SelectItem[] will
 * have one element. Note that the special :ROWKEY: and :ROWID: field IDs can be
 * used here.</li>
 *
 * <li> {@code #{...myDataProvider.options.FIELD_ID}}<br>
 * {@code #{...myDataProvider.options['FIELD_ID']}}<br>
 * {@code #{...myDataProvider.options['VALUE_FIELD_ID,LABEL_FIELD_ID']}}<br>
 * {@code #{...myDataProvider.options['VALUE_FIELD_ID,LABEL_FIELD_ID,
 * DESC_FIELD_ID']}}<br>
 * {@code #{...myDataProvider.options[':ROWKEY:,:ROWKEY:,:ROWKEY:']}}<br>
 * {@code #{...myDataProvider.options[':ROWID:,:ROWID:,:ROWID:']}}<br>
 * --> binds to an array of {@link Option} generated by scanning the rows of the
 * TableDataProvider (without moving the cursor). If the base object is a
 * DataProvider, but not a TableDataProvider, the resulting Option[] will have
 * one element. Note that the special :ROWKEY: and :ROWID: field IDs can be used
 * here.</li>
 *
 * <li> {@code #{...myDataProvider.stringList.FIELD_ID}}<br>
 * {@code #{...myDataProvider.stringList['FIELD_ID']}}<br>
 * {@code #{...myDataProvider.stringList[':ROWKEY:']}}<br>
 * {@code #{...myDataProvider.stringList[':ROWID:']}}<br>
 * --> binds to an array of String generated by scanning the rows of the
 * TableDataProvider (without moving the cursor) and calling toString() on each
 * value. If the base object is a DataProvider, but not a TableDataProvider, the
 * resulting String[] will have one element. Note that the special :ROWKEY: and
 * :ROWID: field IDs can be used here.</li>
 * </ul>
 */
@Resolver
public final class DataProviderELResolver extends ELResolver {

    /**
     * Value key.
     */
    public static final String VALUE_KEY = "value";

    /**
     * Select items key.
     */
    public static final String SELECT_ITEMS_KEY = "selectItems";

    /**
     * Options key.
     */
    public static final String OPTIONS_KEY = "options";

    /**
     * String list key.
     */
    public static final String STRING_LIST_KEY = "stringList";

    /**
     * Row id key.
     */
    public static final String ROWID_FKEY = ":ROWID:";

    /**
     * Row key key.
     */
    public static final String ROWKEY_FKEY = ":ROWKEY:";

    @Override
    public Object getValue(final ELContext context, final Object base,
            final Object property) {

        if (context == null) {
            throw new NullPointerException();
        }
        Object result;
        if (base instanceof DataProvider) {
            DataProvider provider = (DataProvider) base;

            if (VALUE_KEY.equals(property)) {
                result = new ValueData(provider);
                context.setPropertyResolved(true);
                return result;

            } else if (SELECT_ITEMS_KEY.equals(property)) {
                result = new SelectItemsData(provider);
                context.setPropertyResolved(true);
                return result;

            } else if (OPTIONS_KEY.equals(property)) {
                result = new OptionsData(provider);
                context.setPropertyResolved(true);
                return result;

            } else if (STRING_LIST_KEY.equals(property)) {
                result = new StringListData(provider);
                context.setPropertyResolved(true);
                return result;
            }

        } else if (base instanceof ValueData) {
            result = ((ValueData) base).getValue(property.toString());
            context.setPropertyResolved(true);
            return result;

        } else if (base instanceof SelectItemsData) {
            result = ((SelectItemsData) base)
                    .getSelectItems(property.toString());
            context.setPropertyResolved(true);
            return result;
        }
        return null;
    }

    @Override
    public void setValue(final ELContext context, final Object base,
            final Object property, final Object value) {

        if (context == null) {
            throw new NullPointerException();
        }

        if (base instanceof ValueData) {
            ((ValueData) base).setValue("" + property, value);
            context.setPropertyResolved(true);
        }
    }

    @Override
    public boolean isReadOnly(final ELContext context, final Object base,
            final Object property) {

        if (context == null) {
            throw new NullPointerException();
        }
        if (base instanceof ValueData) {
            boolean result = ((ValueData) base).isReadOnly("" + property);
            context.setPropertyResolved(true);
            return result;
        }
        if (base instanceof SelectItemsData) {
            context.setPropertyResolved(true);
            return true;
        }
        if (base instanceof DataProvider) {
            if (VALUE_KEY.equals(property)) {
                context.setPropertyResolved(true);
                return true;

            } else if (SELECT_ITEMS_KEY.equals(property)
                    || OPTIONS_KEY.equals(property)
                    || STRING_LIST_KEY.equals(property)) {
                context.setPropertyResolved(true);
                return true;
            }
        }
        return false;
    }

    @Override
    public Class getType(final ELContext context, final Object base,
            final Object property) {

        if (context == null) {
            throw new NullPointerException();
        }
        if (base instanceof DataProvider) {
            if (VALUE_KEY.equals(property)) {
                context.setPropertyResolved(true);
                return ValueData.class;

            } else if (SELECT_ITEMS_KEY.equals(property)) {
                context.setPropertyResolved(true);
                return SelectItemsData.class;

            } else if (OPTIONS_KEY.equals(property)) {
                context.setPropertyResolved(true);
                return OptionsData.class;

            } else if (STRING_LIST_KEY.equals(property)) {
                context.setPropertyResolved(true);
                return StringListData.class;
            }

        } else if (base instanceof ValueData) {
            Class result = ((ValueData) base).getType("" + property);
            context.setPropertyResolved(true);
            return result;

        } else if (base instanceof SelectItemsData) {
            context.setPropertyResolved(true);
            return ArrayList.class;
        }
        return null;
    }

    @Override
    public Iterator<FeatureDescriptor> getFeatureDescriptors(
            final ELContext context, final Object base) {

        if (context == null) {
            throw new NullPointerException();
        }

        if (base == null) {
            return Arrays.asList(new FeatureDescriptor[0]).iterator();
        }

        List<FeatureDescriptor> result = new ArrayList<FeatureDescriptor>();

        if (base instanceof DataProvider) {
            // for now, don't expose other keys, as they might confuse users
            String[] exposedKeys = {
                VALUE_KEY,
                SELECT_ITEMS_KEY, OPTIONS_KEY
            };
            for (String exposedKey : exposedKeys) {
                FeatureDescriptor desc = new FeatureDescriptor();
                desc.setName(exposedKey);
                desc.setDisplayName(exposedKey);
                desc.setValue(ELResolver.TYPE, String.class);
                desc.setValue(ELResolver.RESOLVABLE_AT_DESIGN_TIME, true);
                result.add(desc);
            }
        } else if (base instanceof ValueData) {
            DataProvider provider = ((ValueData) base).getProvider();
            FieldKey[] fieldKeys = provider.getFieldKeys();
            if (fieldKeys != null) {
                for (FieldKey fieldKey : fieldKeys) {
                    FeatureDescriptor desc = new FeatureDescriptor();
                    String fieldId = fieldKey.getFieldId();
                    String displayName = fieldKey.getDisplayName();
                    if (displayName == null) {
                        displayName = fieldId;
                    }
                    if (fieldId != null) {
                        desc.setName(fieldId);
                        desc.setDisplayName(displayName);
                        //could use String.class here, but it is
                        //syntactically legal to resolve other objects
                        //(like FieldKeys) and pass them in as the property
                        //parameter to getValue, so use Object.class
                        desc.setValue(ELResolver.TYPE, Object.class);
                        desc.setValue(ELResolver.RESOLVABLE_AT_DESIGN_TIME,
                                true);
                        result.add(desc);
                    }
                }
            }
        } else if (base instanceof SelectItemsData) {
            //too complex
            return null;
        }
        return result.iterator();
    }

    @Override
    public Class getCommonPropertyType(final ELContext context,
            final Object base) {

        if (context == null) {
            throw new NullPointerException();
        }
        if (base instanceof DataProvider) {
            return String.class;
        }
        if (base instanceof ValueData || base instanceof SelectItemsData) {
            return Object.class;
        }
        return null;
    }

    /**
     * Value data.
     */
    private final class ValueData {

        /**
         * Data provider.
         */
        private final DataProvider provider;

        /**
         * Create a new instance.
         * @param newProvider new provider
         */
        ValueData(final DataProvider newProvider) {
            this.provider = newProvider;
        }

        /**
         * expose to outer class via getter.
         * @return DataProvider
         */
        public DataProvider getProvider() {
            return provider;
        }

        /**
         * Get a value.
         * @param fieldId id of the field to get the value of
         * @throws PropertyNotFoundException if the field id cannot be found
         * @return Object
         */
        public Object getValue(final String fieldId)
                throws PropertyNotFoundException {

            if (fieldId == null) {
                return null;
            }

            Object value = null;

            if (ROWKEY_FKEY.equals(fieldId)) {
                if (provider instanceof TableDataProvider) {
                    return ((TableDataProvider) provider).getCursorRow();
                }
                if (provider instanceof TableRowDataProvider) {
                    return ((TableRowDataProvider) provider).getTableRow();
                }

            } else if (ROWID_FKEY.equals(fieldId)) {
                if (provider instanceof TableDataProvider) {
                    return ((TableDataProvider) provider)
                            .getCursorRow().getRowId();
                }
                if (provider instanceof TableRowDataProvider) {
                    return ((TableRowDataProvider) provider)
                            .getTableRow().getRowId();
                }

            } else {
                try {
                    FieldKey fk = provider.getFieldKey(fieldId);
                    if (fk != null) {
                        try {
                            value = provider.getValue(fk);
                        } catch (IndexOutOfBoundsException e) {
                            value = null;
                        }
                    } else {
                        throw new PropertyNotFoundException("Field '" + fieldId
                                + "' not found in DataProvider.");
                    }
                } catch (DataProviderException x) {
                    throw new PropertyNotFoundException(x);
                } catch (PropertyNotFoundException x) {
                    throw new PropertyNotFoundException(x);
                }
            }
            return value;
        }

        /**
         * Set the value for a specific field.
         * @param fieldId field id to set the value of
         * @param value new value
         * @throws PropertyNotFoundException if the field id cannot be found
         */
        public void setValue(final String fieldId, final Object value)
                throws PropertyNotFoundException {

            if (fieldId == null) {
                return;
            }

            if (ROWKEY_FKEY.equals(fieldId) && value instanceof RowKey) {
                if (provider instanceof TableDataProvider) {
                    try {
                        ((TableDataProvider) provider)
                                .setCursorRow((RowKey) value);
                        return;
                    } catch (TableCursorVetoException ex) {
                        LogUtil.severe(null, ex);
                    }
                }
                if (provider instanceof TableRowDataProvider) {
                    try {
                        ((TableRowDataProvider) provider)
                                .setTableRow((RowKey) value);
                    } catch (Exception ex) {
                        LogUtil.severe(null, ex);
                    }
                }

            } else if (ROWID_FKEY.equals(fieldId) && value instanceof String) {
                if (provider instanceof TableDataProvider) {
                    try {
                        RowKey row = ((TableDataProvider) provider)
                                .getRowKey((String) value);
                        ((TableDataProvider) provider).setCursorRow(row);
                        return;
                    } catch (DataProviderException ex) {
                        LogUtil.severe(null, ex);
                    }
                }
                if (provider instanceof TableRowDataProvider) {
                    try {
                        RowKey row = ((TableRowDataProvider) provider)
                                .getTableDataProvider()
                                .getRowKey((String) value);
                        ((TableRowDataProvider) provider).setTableRow(row);
                    } catch (DataProviderException ex) {
                        LogUtil.severe(null, ex);
                    }
                }
            } else {
                try {
                    FieldKey fk = provider.getFieldKey(fieldId);
                    if (fk != null) {
                        // <RAVE> - 6334873 - No exception on empty TDP
                        // provider.setValue(fk, value);
                        try {
                            provider.setValue(fk, value);
                        } catch (IndexOutOfBoundsException e) {
                            // Swallow and ignore
                        }
                    // </RAVE>
                    } else {
                        throw new PropertyNotFoundException("Field '" + fieldId
                                + "' not found in DataProvider.");
                    }
                } catch (DataProviderException x) {
                    throw new PropertyNotFoundException(x);
                } catch (PropertyNotFoundException x) {
                    throw new PropertyNotFoundException(x);
                }
            }
        }

        /**
         * Test if a field is read-only.
         * @param fieldId fieldId of the field to test
         * @throws PropertyNotFoundException if the field id cannot be found
         * @return boolean
         */
        public boolean isReadOnly(final String fieldId)
                throws PropertyNotFoundException {

            if (ROWKEY_FKEY.equals(fieldId)
                    || ROWID_FKEY.equals(fieldId)) {
                return false;
            }

            try {
                FieldKey fk = provider.getFieldKey(fieldId);
                if (fk != null) {
                    return provider.isReadOnly(fk);
                } else {
                    throw new PropertyNotFoundException("Field '" + fieldId
                            + "' not found in DataProvider.");
                }
            } catch (DataProviderException x) {
                throw new PropertyNotFoundException(x);
            } catch (PropertyNotFoundException x) {
                throw new PropertyNotFoundException(x);
            }
        }

        /**
         * Get the type of a field.
         * @param fieldId id of the field to get the type of
         * @throws PropertyNotFoundException if the field id cannot be found
         * @return Class
         */
        public Class getType(final String fieldId)
                throws PropertyNotFoundException {

            if (ROWKEY_FKEY.equals(fieldId)) {
                return RowKey.class;

            } else if (ROWID_FKEY.equals(fieldId)) {
                return String.class;
            }

            try {
                FieldKey fk = provider.getFieldKey(fieldId);
                if (fk != null) {
                    return provider.getType(fk);
                } else {
                    throw new PropertyNotFoundException("Field '" + fieldId
                            + "' not found in DataProvider.");
                }
            } catch (DataProviderException x) {
                throw new PropertyNotFoundException(x);
            } catch (PropertyNotFoundException x) {
                throw new PropertyNotFoundException(x);
            }
        }
    }

    /**
     * Select items data.
     */
    private class SelectItemsData {

        /**
         * Data provider.
         */
        private final DataProvider provider;

        /**
         * Create a new instance.
         * @param newProvider data provider.
         */
        SelectItemsData(final DataProvider newProvider) {
            this.provider = newProvider;
        }

        /**
         * Get the value of a field.
         * @param dataProvider data provider
         * @param fieldId id of the field to get the value of
         * @param row row key
         * @return Object
         */
        protected final Object getValue(final DataProvider dataProvider,
                final String fieldId, final RowKey row) {

            if (fieldId == null) {
                return null;
            }

            Object value = null;
            if (ROWKEY_FKEY.equals(fieldId)) {
                if (row != null) {
                    value = row;
                } else if (dataProvider instanceof TableRowDataProvider) {
                    value = ((TableRowDataProvider) dataProvider).getTableRow();
                } else {
                    value = null;
                }
            } else if (ROWID_FKEY.equals(fieldId)) {
                if (row != null) {
                    value = row.getRowId();
                } else if (dataProvider instanceof TableRowDataProvider) {
                    value = ((TableRowDataProvider) dataProvider).getTableRow()
                            .getRowId();
                } else {
                    value = null;
                }
            } else {
                FieldKey fk = dataProvider.getFieldKey(fieldId);
                if (fk != null) {
                    if (row != null
                            && dataProvider instanceof TableDataProvider) {
                        value = ((TableDataProvider) dataProvider)
                                .getValue(fk, row);
                    } else {
                        value = dataProvider.getValue(fk);
                    }
                }
            }
            return value;
        }

        /**
         * Get select item.
         * This implementation does not assume a item value type.
         * @param itemValue item value
         * @param itemLabel item label
         * @param itemDescr item description
         * @return Object
         */
        protected Object getSelectItem(final Object itemValue,
                final Object itemLabel, final Object itemDescr) {

            if (itemValue != null && itemLabel != null && itemDescr != null) {
                return new SelectItem(itemValue, itemLabel.toString(),
                        itemDescr.toString());
            } else if (itemValue != null && itemLabel != null) {
                return new SelectItem(itemValue, itemLabel.toString());
            } else if (itemValue != null) {
                return new SelectItem(itemValue);
            }
            return null;
        }

        /**
         * Returns a List of Objects or SelectItems.
         *
         * Examples based on PERSON database table keys:
         * <ul>
         * <li>{@code "NAME"} -> returns a List filled with SelectItem objects,
         * with the 'itemValue' set to NAME's values</li>
         * <li>{@code "PERSONID,NAME"} -> returns a List filled with SelectItem
         * objects, with the 'itemValue' set to PERSONID's values, and the
         * 'itemLabel' set to NAME's values</li>
         *
         * <li>"PERSONID,NAME,JOBTITLE" -> returns a List filled with
         * SelectItem objects, with the 'itemValue' set to PERSONID's values,
         * the 'itemLabel' set to NAME's values, and the 'itemDescription' set
         * to JOBTITLE's values</li>
         * </ul>
         * Any cases that are out-of-scope throw IllegalArgumentException
         *
         * @param columns columns string
         * @return Object
         */
        @SuppressWarnings("checkstyle:magicnumber")
        public final Object getSelectItems(final String columns) {

            String valueId;
            String labelId = null;
            String descrId = null;

            List<String> cols = new ArrayList<String>();
            String col;
            boolean quoteOpen = false;
            int currStart = 0;
            for (int i = 0; i < columns.length(); i++) {
                char c = columns.charAt(i);
                if (c == '\'') {
                    quoteOpen = !quoteOpen;
                } else if (c == ',' && !quoteOpen) {
                    col = columns.substring(currStart, i);
                    if (col.length() > 0) {
                        cols.add(col);
                    }
                    currStart = i + 1;
                }
            }

            // get the remaining stuff after the last period
            if (currStart < columns.length()) {
                col = columns.substring(currStart);
                cols.add(col);
            }

            String[] args = (String[]) cols.toArray(new String[cols.size()]);
            if (args.length < 1) {
                throw new IllegalArgumentException();
            }
            valueId = args[0];
            if (args.length > 1) {
                labelId = args[1];
            }
            if (args.length > 2) {
                descrId = args[2];
            }

            ArrayList<Object> list = new ArrayList<Object>();
            if (provider instanceof TableDataProvider) {
                TableDataProvider tableProvider = (TableDataProvider) provider;
                int rowCount = tableProvider.getRowCount();
                if (rowCount < 0) {
                    rowCount = 999;
                }
                RowKey[] rows = tableProvider.getRowKeys(rowCount, null);
                for (RowKey row : rows) {
                    Object itemValue = getValue(provider, valueId, row);
                    Object itemLabel = getValue(provider, labelId, row);
                    Object itemDescr = getValue(provider, descrId, row);
                    Object selectItem = getSelectItem(itemValue, itemLabel,
                            itemDescr);
                    if (selectItem != null) {
                        list.add(selectItem);
                    }
                }
            } else {
                Object itemValue = getValue(provider, valueId, null);
                Object itemLabel = getValue(provider, labelId, null);
                Object itemDescr = getValue(provider, descrId, null);
                Object selectItem = getSelectItem(itemValue, itemLabel,
                        itemDescr);
                if (selectItem != null) {
                    list.add(selectItem);
                }

            }
            return list;
        }
    }

    /**
     * Options data.
     */
    private final class OptionsData extends SelectItemsData {

        /**
         * Create a new instance.
         * @param provider data provider
         */
        OptionsData(final DataProvider provider) {
            super(provider);
        }

        @Override
        protected Object getSelectItem(final Object itemValue,
                final Object itemLabel, final Object itemDescr) {

            if (itemValue != null && itemLabel != null && itemDescr != null) {
                return new Option(itemValue, itemLabel.toString(),
                        itemDescr.toString());
            } else if (itemValue != null && itemLabel != null) {
                return new Option(itemValue, itemLabel.toString());
            } else if (itemValue != null) {
                return new Option(itemValue);
            }
            return null;
        }
    }

    /**
     * String list data.
     */
    private final class StringListData extends SelectItemsData {

        /**
         * Create a new instance.
         * @param provider data provider
         */
        StringListData(final DataProvider provider) {
            super(provider);
        }

        @Override
        protected Object getSelectItem(final Object itemValue,
                final Object itemLabel, final Object itemDescr) {
            if (itemValue != null) {
                return itemValue.toString();
            }
            return "";
        }
    }
}
